# Lab 3.4: GitHub Actions and CI/CD Workflows

## Introduction

GitHub Actions allows you to automate your software development workflows directly in your repository. When combined with branch protection rules, it creates a powerful system that automatically tests code, enforces quality standards, and prevents broken code from reaching production.

In this lab, you'll fork a real repository with a working CI/CD pipeline, experiment with automated testing, and see how branch protection rules can require passing checks before allowing merges.

**By the end of this lab, you will:**
- Fork a repository with an existing GitHub Actions workflow
- Understand how CI/CD pipelines trigger on different events
- See automated code quality checks in action
- Experience how failing tests block pull requests
- Configure branch protection to require status checks
- Understand the value of automated quality gates

**Estimated Time:** 25 minutes

---

## Part 1: Fork the Workflow Repository

### Getting the Repository

1. **Navigate to the demo repository:**
   - Go to: https://github.com/PE-VCS/workflow-python-lint
   - This repository contains a Python project with automated CI/CD

2. **Fork the repository:**
   - Click the **Fork** button in the top-right corner
   - Choose your personal account as the destination
   - Keep the repository name as `workflow-python-lint`
   - Ensure "Copy the main branch only" is **unchecked** (we want all branches)
   - Click **Create fork**

3. **Clone your fork locally:**
   ```bash
   git clone https://github.com/YOUR_USERNAME/workflow-python-lint.git
   cd workflow-python-lint
   ```

### Explore the Repository Structure

4. **Examine the project structure:**
   ```bash
   ls -la
   cat README.md
   ```

   You should see:
   - Python source files
   - A `tests/` directory with test files
   - A `.github/workflows/` directory (this contains the CI/CD pipeline)

5. **Look at the workflow file:**
   ```bash
   cat .github/workflows/ci.yml
   ```

**Understanding the Workflow:**

```yaml
name: Python CI

on:
  push:
    branches-ignore: [main]    # Runs on pushes to ANY branch except main
  pull_request:
    branches: [main]           # Runs on PRs targeting main
  workflow_dispatch:           # Allows manual triggering

jobs:
  ci:
    name: Code Quality
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"
          
      - name: Install tools
        run: |
          python -m pip install --upgrade pip
          pip install black pytest
          
      - name: Black check
        run: black --check .  # Code formatting check
        
      - name: Run tests
        run: pytest -q tests      # Run automated tests
```

**What this pipeline does:**
- **Triggers**: Runs on pushes to feature branches and PRs to main
- **Code formatting**: Checks Python code follows Black formatting standards
- **Testing**: Runs all tests in the `tests/` directory
- **Quality gates**: Must pass BOTH checks to be considered successful

---

## Part 2: See the Workflow in Action

### Create a Feature Branch

1. **Create and switch to a new branch:**
   ```bash
   git checkout -b feature/add-calculator
   ```

2. **Add some properly formatted Python code:**
   
   Create a new file `calculator.py`:
   ```python
   def add(a, b):
       """Add two numbers together."""
       return a + b

   def multiply(a, b):
       """Multiply two numbers."""
       return a * b

   def divide(a, b):
       """Divide two numbers."""
       if b == 0:
           raise ValueError("Cannot divide by zero")
       return a / b
   ```

3. **Add a test file:**
   
   Create `tests/test_calculator.py`:
   ```python
   import pytest
   from calculator import add, multiply, divide

   def test_add():
       assert add(2, 3) == 5
       assert add(-1, 1) == 0

   def test_multiply():
       assert multiply(3, 4) == 12
       assert multiply(0, 5) == 0

   def test_divide():
       assert divide(10, 2) == 5
       with pytest.raises(ValueError):
           divide(10, 0)
   ```

4. **Commit and push your changes:**
   ```bash
   git add calculator.py tests/test_calculator.py
   git commit -m "Add calculator functions with tests"
   git push origin feature/add-calculator
   ```

### Watch the Workflow Run

5. **Go to GitHub and check the Actions tab:**
   - Navigate to your forked repository on GitHub
   - Click the **Actions** tab
   - You should see a new workflow run triggered by your push

6. **Click on the running workflow to see details:**
   - Click on the workflow run (named "Python CI")
   - Click on the "Code Quality" job
   - Watch each step execute in real-time
   - The workflow should pass because your code is properly formatted and tests pass

**What you're seeing:**
- **Automated execution**: Code runs on GitHub's servers
- **Step-by-step progress**: Each step shows logs and status
- **Quality checks**: Both Black formatting and pytest tests run automatically

---

## Part 3: Experiencing Failing Checks

Now let's see what happens when quality checks fail.

### Introduce Code Quality Issues

1. **Create a new branch for broken code:**
   ```bash
   git checkout -b feature/broken-code
   ```

2. **Add poorly formatted Python code:**
   
   Create `bad_code.py`:
   ```python
   def poorly_formatted(x,y):
       if x>y:return x
       else:
               return y
   
   def another_function( a, b ):
       result=a+b
       return result
   ```

3. **Add a failing test:**
   
   Create `tests/test_bad_code.py`:
   ```python
   from bad_code import poorly_formatted

   def test_poorly_formatted():
       # This test will fail intentionally
       assert poorly_formatted(5, 3) == 3  # Wrong! Should be 5
   ```

4. **Commit and push the broken code:**
   ```bash
   git add bad_code.py tests/test_bad_code.py
   git commit -m "Add poorly formatted code with failing tests"
   git push origin feature/broken-code
   ```

### Watch the Workflow Fail

5. **Check the Actions tab again:**
   - Go to GitHub Actions
   - Find the new workflow run
   - Click on it to see the failure


6. **Examine the failure details:**
   - Click on the "Code Quality" job
   - Look at the "Black check" step - it should fail due to formatting
   - Look at the "Run tests" step - it should fail due to the wrong assertion

**What you're learning:**
- **Quality gates work**: Bad code is automatically caught
- **Detailed feedback**: You can see exactly what failed and why
- **Fast feedback**: Failures are detected in minutes, not hours

---

## Part 4: Branch Protection with Required Checks

Now let's see how branch protection rules can require these checks to pass before allowing merges.

### Set Up Branch Protection

1. **Go to your repository settings:**
   - Click **Settings** tab in your repository
   - Click **Branches** in the left sidebar
   - Click **Add rule** next to "Branch protection rules"

2. **Configure the protection rule:**
   - **Branch name pattern**: `main`
   - **Require a pull request before merging**
   - **Require status checks to pass before merging**
   - **Require branches to be up to date before merging**
   - In the status checks search box, type "Code Quality" and select it
   - **Restrict pushes that create files that exceed 100 MB**


3. **Save the protection rule:**
   - Click **Create** to save the rule

### Test the Protection

4. **Create a pull request with the broken code:**
   - Go to your repository main page
   - Click **Compare & pull request** for your `feature/broken-code` branch
   - Title: "Test failing CI/CD checks"
   - Description: "This PR intentionally has failing code to test branch protection"
   - Click **Create pull request**

5. **Observe the blocked merge:**
   - The PR should show failing status checks
   - The **Merge pull request** button should be disabled or show "Merging is blocked"
   - You'll see red X marks next to the failing checks


**What you're seeing:**
- **Automatic protection**: GitHub prevents merging broken code
- **Clear feedback**: Status checks show exactly what's failing
- **Quality assurance**: No one can accidentally merge broken code

### Fix the Issues and See Success

6. **Fix the code formatting:**
   ```bash
   git checkout feature/broken-code
   
   # Fix the formatting in bad_code.py
   cat > bad_code.py << 'EOF'
   def poorly_formatted(x, y):
       if x > y:
           return x
       else:
           return y


   def another_function(a, b):
       result = a + b
       return result
   EOF
   ```

7. **Fix the failing test:**
   ```bash
   # Fix the test assertion
   cat > tests/test_bad_code.py << 'EOF'
   from bad_code import poorly_formatted

   def test_poorly_formatted():
       # Fixed test - should pass now
       assert poorly_formatted(5, 3) == 5  # Correct!
   EOF
   ```

8. **Commit and push the fixes:**
   ```bash
   git add bad_code.py tests/test_bad_code.py
   git commit -m "Fix code formatting and test assertion"
   git push origin feature/broken-code
   ```

9. **Watch the checks pass:**
   - Go back to your pull request
   - Watch the new workflow run
   - Once it passes, the **Merge pull request** button should become available
   - Merge the pull request


---

## Part 5: Create Your Own Workflow Experiment

### Add Your Own Feature

1. **Create a new branch for your own code:**
   ```bash
   git checkout main
   git pull origin main
   git checkout -b feature/my-experiment
   ```

2. **Add your own Python function and tests:**
   
   Ideas for functions to implement:
   - String manipulation (reverse, palindrome check)
   - List operations (find max, sort, filter)
   - Math utilities (factorial, fibonacci)
   - Data validation (email format, phone number)

   Example - create `string_utils.py`:
   ```python
   def reverse_string(text):
       """Reverse a string."""
       return text[::-1]

   def is_palindrome(text):
       """Check if a string is a palindrome."""
       cleaned = text.lower().replace(" ", "")
       return cleaned == cleaned[::-1]

   def count_vowels(text):
       """Count vowels in a string."""
       vowels = "aeiouAEIOU"
       return sum(1 for char in text if char in vowels)
   ```

   And `tests/test_string_utils.py`:
   ```python
   from string_utils import reverse_string, is_palindrome, count_vowels

   def test_reverse_string():
       assert reverse_string("hello") == "olleh"
       assert reverse_string("") == ""

   def test_is_palindrome():
       assert is_palindrome("racecar") == True
       assert is_palindrome("hello") == False
       assert is_palindrome("A man a plan a canal Panama") == True

   def test_count_vowels():
       assert count_vowels("hello") == 2
       assert count_vowels("xyz") == 0
   ```

3. **Intentionally break something first:**
   - Add a function with bad formatting
   - OR add a test that fails
   - Push and create a PR to see it get blocked

4. **Then fix it and see the protection work:**
   - Fix the formatting or test
   - Push again and watch the checks pass
   - Merge when everything is green

### Experiment Ideas

Try these experiments to learn more:

**Formatting Experiments:**
- Remove spaces around operators: `x=y+z` (Black will catch this)
- Use inconsistent indentation
- Have lines longer than 88 characters

**Test Experiments:**
- Write a test that expects the wrong result
- Import a function that doesn't exist
- Have a test that raises an unexpected exception

**Workflow Understanding:**
- Push directly to main (if allowed) vs. feature branch
- Try the manual "workflow_dispatch" trigger in the Actions tab
- Look at the workflow logs to understand timing

---

## Part 6: Understanding Real-World Value

### Why This Matters

**In Professional Development:**

1. **Quality Assurance**
   - Automatically catch bugs before they reach production
   - Enforce consistent code style across the team
   - Ensure all tests pass before deployment

2. **Team Collaboration**
   - Reviewers can focus on logic, not formatting
   - Confidence that merged code meets quality standards
   - Faster development cycles with automated checks

3. **Risk Reduction**
   - Prevent broken code from reaching customers
   - Catch security vulnerabilities early
   - Ensure documentation and tests exist

**Common CI/CD Checks in Real Projects:**
- **Linting**: Code style and potential bugs (Black, ESLint, etc.)
- **Testing**: Unit tests, integration tests, end-to-end tests
- **Security**: Vulnerability scanning, dependency checks
- **Performance**: Load testing, memory usage analysis
- **Documentation**: Ensure README and docs are updated

### Scaling Up

**What you could add to this workflow:**
- **Code coverage**: Require tests to cover X% of code
- **Security scanning**: Check for vulnerable dependencies
- **Documentation**: Generate and deploy docs automatically
- **Deployment**: Automatically deploy passing code to staging
- **Notifications**: Slack/email alerts for failures

---

## Part 7: Clean Up and Reflect

### Optional: Clean Up Branches

If you want to clean up your repository:

```bash
git checkout main
git branch -d feature/add-calculator feature/broken-code feature/my-experiment
git push origin --delete feature/add-calculator feature/broken-code feature/my-experiment
```

### Understanding GitHub Actions Pricing

**Important for real projects:**
- **Public repositories**: GitHub Actions is free with unlimited minutes
- **Private repositories**: Free tier includes 2,000 minutes/month
- **Self-hosted runners**: Can run on your own servers for unlimited usage

---

## Conclusion

Congratulations! You've experienced a complete CI/CD workflow with GitHub Actions. You learned:

- **Workflow automation**: How GitHub Actions automatically runs checks on code changes
- **Quality gates**: How automated tests and formatting checks prevent bad code from being merged
- **Branch protection**: How to require passing status checks before allowing merges
- **Real-world development**: The same patterns used by professional development teams
- **Fast feedback loops**: Catching issues in minutes instead of hours or days

**Key Takeaways:**

1. **Automation prevents human error**: Computers are better at consistently checking code quality

2. **Fast feedback is valuable**: Finding bugs in minutes vs. days saves time and money

3. **Branch protection enforces quality**: No one can bypass the quality gates, even by accident

4. **CI/CD scales with teams**: The bigger the team, the more valuable automated quality checks become

5. **Configuration is code**: Your workflows are defined in code and version controlled

## Next Steps

**In your future projects:**
- Set up GitHub Actions for your personal projects
- Experiment with different types of checks (security, performance, etc.)
- Learn about deployment workflows (CI/CD to production)
- Explore marketplace actions for common tasks
- Consider advanced patterns like matrix builds, caching, and secrets management

**For further learning:**
- GitHub Actions documentation: https://docs.github.com/en/actions
- Marketplace actions: https://github.com/marketplace?type=actions
- Workflow examples: https://github.com/actions/starter-workflows

## Reflection Questions

1. How would automated quality checks have helped in your previous coding projects?
2. What types of checks would be most valuable for the programming languages you use?
3. How does requiring status checks change the way teams collaborate on code?
4. What's the difference between preventing bugs vs. catching them after deployment?
5. How could you use GitHub Actions for non-coding tasks (documentation, deployment, notifications)?

**Excellent work on mastering GitHub Actions and CI/CD workflows!**
