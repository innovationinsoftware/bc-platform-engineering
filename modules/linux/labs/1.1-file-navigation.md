# File Navigation

Understanding the Linux file system establishes a strong foundation in Linux. 
The shell serves as a user interface to the operating system, taking commands from the user, interpreting them, and passing them to the kernel for execution.

The shell will be our main tool for working with files. When working with files, it's important to remember that Linux does not have a recycling bin. 
While you work on this lab, consider how commands like `mv`, `rm`, or `cp` can cause data loss and how to use them safely. 

### Estimated Time: 20 Minutes


## Part 1: Basic navigation

1. Print the current working directory
   ```
    pwd
   ```
2. Navigate to your home folder
   ```
    cd ~
    # cd
    # cd $HOME
   ```
3. Create a folder named scripts
   ```
    mkdir scripts
   ```
4. Briefly review the manual page for `mkdir`. Notice the **-p** option.
   ```
    man mkdir
    # use /-p enter to search for -p, similar to the find feature of a browser. You can use n for next and shift+n for previous.
   ```
5. Create two folders with one command, code/app and ~/code/artifacts/files
    ```
    mkdir -p code/app ~/code/artifacts/files
    ```

6. Navigate between code/app, home, and code/artifacts/files a few times. Notice how the **Tab key** will autofill paths.


## Part 2: File Manipulation 

1. Navigate to your home folder. Create an empty file named data.txt with a command. Create a hidden file named .data.txt
    ```
    cd
    touch data.txt .data.txt
    ```
2. List all files in current directory with long listing format. Take note of the date, file permissions, file size and ownership. Then use shell globing to list files ending in .txt
    ```
    ls -la # -a is for all files, including hidden files
    ls -l *.txt # will list files ending in .txt of current directory
    ```
3. echo something to the standard output of the terminal. Append that output to ~/code/artifacts/data.txt. 
    ```
    echo welcome to Linux
    # use up key, and tab key for file path
    echo welcome to Linux >> ~/code/artifacts/data.txt # using >> appends the output of a command to a file
    ```
4. Echo something different to ~/data.txt. 
    ```
    echo Linux Torvalds founded Linux from Unix >> ~/data.txt
    ```
5. Print the contents of both ~/code/artifacts/data.txt and ~/data.txt to the standard output
    ```
    cat ~/code/artifacts/data.txt
    cat ~/data.txt
    ```
    
6. copy ~/code/artifacts/data.txt into ~/data.txt. Be sure to make a backup, so we do not lose the contents of existing data.txt. Confirm the backup worked.
    ```
    # using absolute paths. -b is for backup
    cp -b ~/code/artifacts/data.txt ~/data.txt

    # using relative paths
    cd ~
    # cp -b code/artifacts/data.txt data.txt

    # List all files (notice a backup file with a ~ or suffix)
    ls -la


    cat data.txt~ # confirm the backup
    cat data.txt # should be same as cat ~/code/artifacts/data.txt
    ```
7. Use the `diff` command to compare files for differences. The diff command shows line-by-line differences, where lines beginning with < exist only in the first file, and lines beginning with > exist only in the second.
   ```
   diff ~/code/artifacts/data.txt ~/data.txt
   diff ~/data.txt ~/data.txt~ 
   ```
    
7. Rename the data.txt~ file to backup.txt.
    ```
    mv data.txt~ backup.txt
    ```

8. Delete ~/data.txt
    ```
    rm ~/data.txt
    ```

9. Use the `history` command to see the commands you ran. You can always run `history -a` to append your current history. This is helpful when you disconnect from your server, as it will not save your history without a clean exit.
    ```
    history
    history -a # append your current history, in case you are disconnected
    ``` 

## Part 3: File System Structure
    
1. Use the less command to read .bashrc and .bash_profile. These shell scripts are profiles. Profiles execute when the associated user logs in. The less command is handy for reading and searching in large files.
    ```
    less ~/.bash_profile # use q to exit
    less ~/.bashrc
    ```
2. Navigate to the root folder and run ls. Use the ls command on the folders you see. Different operating systems may have different locations for some folders.
   ```
    cd /
    ls
   ls /bin         # essential user binaries (commands available to all users)
   ls /boot        # files needed for booting (kernel, initramfs, bootloader)
   ls /dev         # device files representing hardware (disks, terminals, USBs)
   ls /etc         # system-wide configuration files
   ls /etc/logrotate.d  # log rotation configuration files
   ls /etc/sudoers.d    # additional configuration for sudo access
   ls /etc/profile.d    # scripts executed when any user logs in
   ls /etc/ssh          # SSH daemon configuration and host keys
   ls /lib         # shared libraries required by binaries in /bin and /sbin
   ls /lib64       # 64-bit shared libraries (on 64-bit systems)
   ls /media       # mount point for removable media (USB drives, DVDs)
   ls /mnt         # temporary mount point for filesystems (manual mounting)
   ls /opt         # optional software or add-on packages
   ls /proc        # virtual filesystem providing process and kernel information
   ls /root        # home directory for the root user
   ls /run         # volatile runtime data (PID files, sockets) cleared on reboot
   ls /sbin        # system binaries (administrative commands)
   ls /srv         # data served by system services (web, FTP, etc.)
   ls /sys         # kernel interface exposing hardware and driver info
   ls /tmp         # temporary files, cleared on reboot
   ls /usr         # user programs, libraries, documentation shared system-wide
   ls /var         # variable application data (logs, spool, cache)
   ls /var/log     # system and application log files                               
   ls /home        # home directories for normal users

   cd ~

   ```

   ```mermaid
   graph LR
       ROOT["/ (root)"]
       ROOT --> BIN["/bin (user binaries)"]
       ROOT --> USR["/usr (shared user data)"]
       ROOT --> VAR["/var (variable data)"]
       ROOT --> ETC["/etc (system configs)"]
       ROOT --> HOME["/home (user directories)"]
       ROOT --> TMP["/tmp (temporary files)"]
   
       VAR --> LOG["/var/log (log files)"]
   
       BIN --> LS["ls"]
       BIN --> CD["cd"]
   ```

## Part 4: Bonus Challenge

Create a new folder called practice inside your home directory and move a copy of backup.txt into it.
Inside practice, create a hidden file and append some text to it using echo and output redirection.
Finally, list all files (including hidden ones) with ls -la and verify their sizes and permissions.

## Cleanup
Before you leave: Clean up your working environment using the following commands.
Be careful running these cleanup commands. Use the -i option to be prompted for each deleted item. Skip -i when deleting many files, but be cautious.
```
cd ~
rm -i *.txt # deletes all files ending in .txt. 
rm -ri scripts
rm -ri practice
rm -rf code
```

## Conclusion
In this lab, we explored the foundations of navigating and managing files in Linux — a core skill for any system administrator. You learned how to move through directories, create and manipulate files, view hidden files, and understand the structure of the Linux filesystem.

We also practiced important commands such as pwd, cd, ls, mkdir, cp, mv, rm, and cat, gaining confidence with command-line operations and shortcuts like tab completion and shell globbing.

These skills form the groundwork for more advanced administration tasks. In the next lab, we’ll build on this knowledge by working with permissions, ownership, and executable files, learning how Linux controls access and execution across users and groups.
