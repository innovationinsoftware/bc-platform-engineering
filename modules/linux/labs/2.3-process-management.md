# Lab 2.3: Advanced Process Management

Process management extends beyond starting and stopping processes. Understanding how processes interact with files, managing process priority, and handling orphaned processes are critical skills for production system administration.

When troubleshooting issues like "file is busy" errors, identifying which process has a file open, or managing resource-intensive applications, these advanced process management techniques become essential.

This lab builds upon foundational process monitoring skills by exploring file descriptors, process relationships, and priority management.

### Estimated Time: 15 Minutes

## Part 1: Understanding Process File Descriptors with lsof

The `lsof` (List Open Files) command reveals which files, sockets, and resources a process is using. Remember: in Linux, everything is a fileâ€”including network sockets, pipes, and devices.

1. Create a workspace and explore basic lsof usage
```bash
mkdir -p ~/process_mgmt && cd ~/process_mgmt

# Start a simple process that we can examine
sleep 300 > output.txt &
SLEEP_PID=$!
echo "Sleep process PID: $SLEEP_PID"
```

2. Examine all files opened by a specific process
```bash
# View all open files for our sleep process
lsof -p $SLEEP_PID

# Notice the output columns:
# COMMAND: Process name
# PID: Process ID
# USER: Process owner
# FD: File descriptor (0=stdin, 1=stdout, 2=stderr, numbers=open files)
# TYPE: Type of file (REG=regular file, DIR=directory, CHR=character device)
# DEVICE: Device numbers
# SIZE/OFF: File size or offset
# NODE: Inode number
# NAME: Filename or resource name
```

3. Understanding what the output reveals
```bash
# The executable file used to create the process is shown with txt (text/code)
# You'll see entries like:
# - /usr/bin/sleep (txt) - the binary that's executing
# - /lib64/libc.so.6 (mem) - shared libraries loaded in memory
# - output.txt (1w) - file descriptor 1 (stdout) opened for writing

# Filter to see just regular files (not libraries)
lsof -p $SLEEP_PID | grep -E "REG|NAME"
```

4. Create a test file and find which process has it open
```bash
# Start a process that keeps a file open
tail -f output.txt &
TAIL_PID=$!

# Find which processes have output.txt open
lsof output.txt

# This shows all processes accessing this file
# Useful when you get "file is busy" or can't delete a file

# Clean up
kill $TAIL_PID $SLEEP_PID
```

5. Practical lsof scenarios
```bash
# Find all files opened by your current user
lsof -u $USER | head -20

# Find processes listening on network ports
lsof -i -P -n

# Find what process is using a specific port
# lsof -i :22  # SSH port example

# Find all processes accessing a specific directory
touch test_file.txt
cat test_file.txt &
CAT_PID=$!
lsof +D ~/process_mgmt | head -10
kill $CAT_PID 2>/dev/null
```

## Part 2: Understanding ps Command Headers

The `ps` command provides detailed process information. Understanding key headers helps you diagnose system issues effectively.

1. Explore important ps output fields
```bash
# Start some test processes
sleep 1000 &
sleep 2000 &
dd if=/dev/zero of=/dev/null &
DD_PID=$!

# Display key process metrics
ps -eo pid,ppid,user,pri,ni,vsz,rss,pmem,pcpu,stat,time,cmd | grep -E "PID|sleep|dd" | head -10
```

2. Understanding key headers:
```bash
# PID    = Process ID
# PPID   = Parent Process ID (who started this process)
# USER   = Process owner
# PRI    = Priority (kernel's scheduling priority, higher = higher priority)
# NI     = Nice value (-20 to 19, lower = higher priority)
# VSZ    = Virtual memory size (KB) - total memory allocated
# RSS    = Resident Set Size (KB) - physical RAM currently used
# %MEM   = Percentage of physical memory used
# %CPU   = Percentage of CPU time used
# STAT   = Process state (R=running, S=sleeping, D=uninterruptible sleep, Z=zombie, T=stopped)
# TIME   = Total CPU time consumed
# CMD    = Command that started the process

# View process states in detail
ps aux | grep -E "STAT|sleep|dd" | head -10

# STAT codes explained:
# R = Running or runnable (on run queue)
# S = Interruptible sleep (waiting for an event)
# D = Uninterruptible sleep (usually I/O)
# T = Stopped (by job control signal)
# Z = Zombie (terminated but not cleaned up by parent)
# Additional flags: < = high-priority, N = low-priority, + = in foreground process group
```

3. Find parent-child process relationships
```bash
# Create a parent-child relationship
bash -c 'sleep 5000 & sleep 6000 &' &
BASH_PID=$!

# View process tree
ps -ef --forest | grep -A 5 $BASH_PID

# Or use pstree for better visualization
pstree -p $BASH_PID

# Clean up
kill $BASH_PID $DD_PID 2>/dev/null
pkill -P $BASH_PID 2>/dev/null
```

## Part 3: Process Priority with nice and renice

Process priority determines how much CPU time the kernel allocates to a process. The "nice" value ranges from -20 (highest priority) to 19 (lowest priority). The default is 0.

1. Understanding and setting nice values
```bash
# Start a normal priority CPU-intensive process
stress --cpu 1 --timeout 60s &
NORMAL_PID=$!

# Check its nice value and priority
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Start a low-priority (nice) process
nice -n 10 stress --cpu 1 --timeout 60s &
NICE_PID=$!

# Start a high-priority process (requires sudo for negative nice)
sudo nice -n -10 stress --cpu 1 --timeout 60s &
HIGH_PID=$!

# Compare priorities (notice PRI values differ based on nice)
ps -o pid,ni,pri,pcpu,cmd -p $NORMAL_PID,$NICE_PID,$HIGH_PID

# Watch CPU distribution (high-priority gets more CPU time)
sleep 3
ps -o pid,ni,pcpu,cmd -p $NORMAL_PID,$NICE_PID,$HIGH_PID
```

Note: If `stress` isn't installed, run: `sudo dnf install -y stress`

2. Changing priority of running processes with renice
```bash
# Change priority of running process (make it nicer/lower priority)
renice -n 15 -p $NORMAL_PID

# Check the change
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Increase priority (requires sudo)
sudo renice -n -5 -p $NORMAL_PID

# Verify change
ps -o pid,ni,pri,cmd -p $NORMAL_PID

# Clean up CPU-intensive processes
kill $NORMAL_PID $NICE_PID 2>/dev/null
sudo kill $HIGH_PID 2>/dev/null
```

3. Practical use cases for nice/renice
```bash
# Run a backup script with low priority so it doesn't impact performance
nice -n 19 tar -czf backup.tar.gz ~/process_mgmt 2>/dev/null &
BACKUP_PID=$!

# Monitor its impact
ps -o pid,ni,pcpu,cmd -p $BACKUP_PID

# Wait for it and clean up
wait $BACKUP_PID 2>/dev/null
rm -f backup.tar.gz
```
## Part 4: Zombies

3. Understanding zombie processes
```bash
# Create a zombie process (child exits but parent doesn't read status)
cat << 'EOF' > zombie_maker.sh
#!/bin/bash
# Child process that exits immediately
bash -c 'exit 0' &
CHILD_PID=$!
echo "Created child with PID: $CHILD_PID"
echo "Parent ($$) sleeping for 30 seconds without cleaning up child..."
sleep 30
echo "Parent exiting"
EOF

chmod +x zombie_maker.sh
./zombie_maker.sh &
ZOMBIE_PARENT=$!

# Quickly check for zombie (look for Z or <defunct>)
sleep 2
ps aux | grep -E "defunct|Z"
ps -o pid,ppid,stat,cmd | grep -E "STAT|Z"

# Zombies are cleaned up when parent exits or calls wait()
wait $ZOMBIE_PARENT 2>/dev/null
```

## Cleanup
```bash
# Kill any remaining background processes
pkill -f "sleep [0-9]" 2>/dev/null
cd ~
rm -rf ~/process_mgmt
```

## Conclusion

In this lab, you've gained advanced process management skills essential for production Linux administration:

- **lsof mastery**: Identifying open files, sockets, and file descriptors for any process, troubleshooting "file is busy" errors
- **ps interpretation**: Understanding critical process metrics like PRI, NI, VSZ, RSS, and STAT codes to diagnose system behavior
- **Process priority**: Managing CPU allocation with nice and renice to balance system load
- **Zombies**: Understanding zombie processes and how they're cleaned up

These advanced techniques are crucial for:
- Troubleshooting "file is busy" errors and locked files
- Investigating resource consumption and performance issues
- Managing system load by adjusting process priorities
- Preventing runaway processes from consuming all system resources
