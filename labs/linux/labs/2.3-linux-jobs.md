# Lab 2.3: Linux Jobs and Process Control

Jobs in Linux are processes that you start and manage within your shell session. Understanding job control allows you to run multiple tasks simultaneously, pause and resume processes, and efficiently manage system resources.

System administrators frequently need to run long-running processes, monitor system tasks, and control background services. Job control skills enable you to multitask effectively and manage processes without losing work or blocking your terminal.

Learning to use signals properly ensures you can gracefully stop processes when needed, or force termination when processes become unresponsive.

### Estimated Time: 15 Minutes

## Part 1: Background Jobs and Job Control

1. Create a workspace and start your first background job
```
mkdir -p ~/jobs_practice && cd ~/jobs_practice
sleep 300 &
echo "Job started with PID: $!"
```

2. Check running jobs and processes
```
jobs                    # List active jobs in current shell
ps -ef | grep [s]leep   # Find sleep processes (brackets prevent grep from matching itself)
```

3. Start multiple background jobs
```
sleep 600 &
sleep 900 &
sleep 1200 &
jobs                    # Notice job numbers [1], [2], [3]
```

4. Practice job termination using different methods
```
kill %2                 # Kill job number 2
kill %+                 # Kill most recent job (job 3)
kill %-                 # Kill second most recent job (job 1)
jobs                    # Verify jobs are terminated
```

## Part 2: Foreground and Background Control

1. Start a foreground process and practice job control
```
sleep 400               # This blocks your terminal
# Press Ctrl+Z to suspend the process
```

2. After pressing Ctrl+Z, manage the suspended job
```
jobs                    # Shows job as "Stopped"
bg %1                   # Resume job 1 in background
jobs                    # Shows job as "Running"
```

3. Practice bringing jobs to foreground
```
sleep 500 &             # Start in background
fg %1                   # Bring to foreground
# Press Ctrl+Z to suspend again
bg %1                   # Resume in background
```

4. Start multiple jobs and practice switching between them
```
sleep 800 &
sleep 900 &
jobs
fg %1                   # Bring job 1 to foreground
# Press Ctrl+Z
fg %2                   # Bring job 2 to foreground  
# Press Ctrl+Z
jobs                    # Both should show as "Stopped"
```

## Part 3: Process Signals

1. Learn about available signals
```
kill -l                 # List all available signals
```

The most commonly used signals include:

- **SIGTERM (15)**: Politely asks a process to terminate. This is the default signal for `kill` and allows the process to clean up resources before exiting.
- **SIGKILL (9)**: Forcefully terminates a process immediately. Cannot be caught or ignored by the process.
- **SIGINT (2)**: Interrupts a process (equivalent to pressing Ctrl+C). Allows graceful shutdown.
- **SIGHUP (1)**: Originally sent when terminal disconnects. Often used to reload configuration files.
- **SIGSTOP (19)**: Pauses a process (cannot be caught or ignored). Use with `kill -STOP`.
- **SIGCONT (18)**: Resumes a stopped process. Use with `kill -CONT`.

2. Practice using different signals
```
sleep 600 &
kill -STOP %1           # Pause the job
jobs                    # Shows as "Stopped"
kill -CONT %1           # Resume the job
jobs                    # Shows as "Running"
```

3. Test graceful vs forceful termination
```
sleep 800 &
kill -TERM %1           # Graceful termination (same as kill %1)
sleep 5 && jobs         # Check if process terminated

sleep 900 &
kill -9 %1              # Force kill if graceful termination fails
jobs                    # Verify termination
```

## Part 4: Advanced Job Management

1. Practice with command substitution and job monitoring
```
# Start jobs with descriptive commands
(echo "Starting long task..." && sleep 300) &
(echo "Starting backup..." && sleep 400) &
jobs -l                 # List jobs with PID numbers
```

2. Monitor job completion
```
# Start a short job to see completion
sleep 10 &
jobs
sleep 15
jobs                    # Job should be completed and removed
```

3. Practice nohup for persistent jobs
```
nohup sleep 600 &       # Job continues even if terminal closes
jobs
ps -ef | grep [s]leep   # Shows process still running
kill %1                 # Clean up the nohup job
```

## Cleanup
```
# Kill any remaining background jobs
jobs
kill $(jobs -p) 2>/dev/null  # Kill all background jobs
cd ~
rm -rf ~/jobs_practice
```

## Conclusion

In this lab, you mastered essential job control and process management skills for Linux system administration:

- **Job management**: Starting, stopping, and switching between foreground and background jobs
- **Process control**: Using job numbers, PIDs, and job references (%1, %+, %-) to manage processes
- **Signal handling**: Understanding common signals (SIGTERM, SIGKILL, SIGINT, SIGHUP) and when to use them
- **Background operations**: Running tasks without blocking your terminal using `&` and `nohup`
- **Process monitoring**: Using `jobs`, `ps`, and process identification to track running tasks

These skills are essential for managing system services, running maintenance scripts, and handling multiple administrative tasks simultaneously. Understanding when to use graceful termination (SIGTERM) versus force termination (SIGKILL) helps maintain system stability and data integrity.

In the next lab, we'll explore automation and scheduling to build upon these process management foundations.
