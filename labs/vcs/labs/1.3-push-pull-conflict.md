# Mastering Push and Pull Workflows

Now that you understand the basics of Git and GitHub, it's time to master the push and pull workflow. This is the core of how developers work with Git every day: making changes locally, pushing them to GitHub, pulling updates from GitHub, and handling conflicts when things don't sync perfectly.

In this lab, you'll practice the real-world workflow of syncing changes between your local computer and GitHub. You'll make changes in different places and learn how to keep everything synchronized.

### Estimated Time: 45 Minutes

**Prerequisites:** Complete Lab 1.1 and Lab 1.2. You should have your `git_practice` repository cloned and connected to GitHub.

## Part 1: Verifying Your Setup

Let's make sure your repository is ready for this lab.

1. Open Git Bash and navigate to your repository
   ```bash
   cd ~/Documents/git_practice
   
   # Verify you're in the right place
   pwd
   ```

2. Check your Git status
   ```bash
   git status
   
   # Should show: "On branch main" and "nothing to commit, working tree clean"
   ```

3. Verify your remote connection
   ```bash
   git remote -v
   
   # Should show your GitHub repository URL
   ```

4. Check if you're in sync with GitHub
   ```bash
   git fetch
   git status
   
   # Should say "Your branch is up to date with 'origin/main'"
   ```

If you see any errors, make sure you completed Lab 1.2 successfully!

## Part 2: The Basic Push Workflow

Let's practice the standard workflow: make local changes, commit them, and push to GitHub.

1. Create a new Python file
   ```bash
   # Create a simple Python script
   cat > calculator.py << 'EOF'
   # Simple Calculator
   
   def add(a, b):
       return a + b
   
   def subtract(a, b):
       return a - b
   
   if __name__ == "__main__":
       print("Calculator loaded!")
       print(f"5 + 3 = {add(5, 3)}")
       print(f"10 - 4 = {subtract(10, 4)}")
   EOF
   
   # Test it
   python calculator.py
   ```

2. Check the status
   ```bash
   git status
   
   # You'll see calculator.py as untracked
   ```

3. Stage and commit
   ```bash
   # add files to staging area
   # commit changes
   ```

4. **Challenge: Push to GitHub**
   ```bash
   # Use the git push command you learned in Lab 1.2
   # (Hint: You don't need to specify origin main anymore)
   
   
   
   # Your command here
   ```

5. Verify on GitHub
   - Open your browser and go to your `git_practice` repository
   - You should see `calculator.py` in the file list
   - Click on it to view the code with syntax highlighting

## Part 3: Making Multiple Changes Before Pushing

In real work, you often make several commits locally before pushing to GitHub.

1. Add a multiply function
   ```bash
   # Append to calculator.py
   cat >> calculator.py << 'EOF'
   
   def multiply(a, b):
       return a * b
   EOF
   
   # View the file
   cat calculator.py
   ```

2. Commit this change
   ```bash
   # Stage and commit
   # (Challenge: Do this without looking at the exact commands)
   
   
   
   # Your commands here
   ```

3. Add a divide function
   ```bash
   # Append to calculator.py
   cat >> calculator.py << 'EOF'
   
   def divide(a, b):
       if b == 0:
           return "Error: Cannot divide by zero"
       return a / b
   EOF
   ```

4. Commit this change too
   ```bash
   # Stage and commit with message "Add divide function with zero check"
   
   
   
   # Your commands here
   ```

5. Check your local commit history
   ```bash
   git log --oneline
   
   # You should see your two new commits at the top
   ```

6. **Challenge: Push both commits to GitHub**
   ```bash
   # Push all your local commits to GitHub
   
   
   
   # Your command here
   ```

7. Verify on GitHub
   - Refresh your repository page
   - Click on the commit count
   - You should see both new commits listed

## Part 4: Pulling Changes from GitHub

Now let's practice the reverse: making changes on GitHub and pulling them to your local repository.

1. Edit a file on GitHub
   - Go to your `git_practice` repository on GitHub
   - Click on `calculator.py`
   - Click the pencil icon to edit
   - Add this at the end of the file:
     ```python
     
     def power(a, b):
         return a ** b
     ```
   - Commit message: "Add power function via GitHub"
   - Click **Commit changes**

2. Check your local status
   ```bash
   # Back in Git Bash
   git status
   
   # It says you're up to date... but you're not! Why?
   ```

3. Fetch updates from GitHub
   ```bash
   git fetch
   
   # Now check status again
   git status
   
   # Now it says "Your branch is behind 'origin/main' by 1 commit"
   ```

   **What's the difference?**
   - `git fetch`: Downloads info about changes but doesn't apply them
   - `git pull`: Downloads AND applies changes (fetch + merge)

4. Pull the changes
   ```bash
   git pull
   
   # You'll see: "Updating abc123..def456"
   # Fast-forward means Git simply moved your branch forward
   ```

5. Verify the change is local now
   ```bash
   cat calculator.py
   
   # You should see the power function at the bottom!
   ```

## Part 5: The Push-Pull Cycle

Let's practice a realistic workflow: work locally, push, make changes on GitHub, pull, repeat.

1. Update README locally
   ```bash
   # Add to README.md
   echo "" >> README.md
   echo "## Features" >> README.md
   echo "- Calculator with basic math operations" >> README.md
   echo "- Error handling for division by zero" >> README.md
   ```

2. **Challenge: Commit and push**
   ```bash
   # Stage, commit with message "Add features section to README", and push
   
   
   
   
   # Your commands here
   ```

3. Add more to README on GitHub
   - Go to GitHub and click on `README.md`
   - Click the pencil icon to edit
   - Add this at the end:
     ```markdown
     
     ## Technologies
     - Python 3
     - Git & GitHub
     ```
   - Commit message: "Add technologies section"
   - Click **Commit changes**

4. **Challenge: Pull the changes**
   ```bash
   # Pull the changes from GitHub to your local repository
   
   
   # Your command here
   ```

5. Verify both changes are in your local README
   ```bash
   cat README.md
   
   # You should see both Features and Technologies sections
   ```

## Part 6: Understanding When to Push and Pull

Best practices for the push-pull workflow:

1. **Before starting work each day:**
   ```bash
   git pull
   
   # This ensures you have the latest changes
   ```

2. **After completing a logical unit of work:**
   ```bash
   git add --all
   git commit -m "Descriptive message"
   git push
   
   # Push frequently to back up your work
   ```

3. **Check status often:**
   ```bash
   git status
   
   # Know what's changed before you commit
   ```

4. **View what changed:**
   ```bash
   git diff
   
   # See unstaged changes
   
   git diff --staged
   
   # See staged changes
   ```

Let's practice using `git diff`:

1. Make a small change
   ```bash
   echo "print('Calculator ready!')" >> calculator.py
   ```

2. View the change before staging
   ```bash
   git diff
   
   # You'll see the new line highlighted in green with a +
   ```

3. Stage it and view again
   ```bash
   git add calculator.py
   
   git diff
   # Nothing! It's staged now
   
   git diff --staged
   # Now you see the change
   ```

4. Commit it
   ```bash
   git commit -m "Add startup message to calculator"
   ```

## Part 7: Handling Out-of-Sync Repositories and Merge Conflicts

What happens if you forget to pull before making changes? Let's simulate this and learn how to resolve conflicts.

1. Edit `hello.py` on GitHub
   - Go to GitHub and click on `hello.py`
   - Click the pencil icon
   - **Replace the entire content** with:
     ```python
     print("Hello from GitHub!")
     print("This version was edited on GitHub")
     ```
   - Commit message: "Update greeting from GitHub"
   - Commit the change

2. Now edit `hello.py` locally (without pulling first)
   ```bash
   # First, let's overwrite hello.py with a different version
   cat > hello.py << 'EOF'
   print("Hello from my local computer!")
   print("This version was edited locally")
   EOF
   
   # View what you created
   cat hello.py
   ```

3. Try to commit and push
   ```bash
   git add hello.py
   git commit -m "Update greeting locally"
   
   # Now try to push
   git push
   ```

   **You'll get an error!**
   ```
   ! [rejected]        main -> main (fetch first)
   error: failed to push some refs to 'https://github.com/...'
   hint: Updates were rejected because the remote contains work that you do
   hint: not have locally. This is usually caused by another repository pushing
   hint: to the same ref. You may want to first integrate the remote changes
   hint: (e.g., 'git pull ...') before pushing again.
   ```

4. Pull the changes first
   ```bash
   git pull
   ```

   **Git may ask you to choose a merge strategy!**
   
   If this is your first time encountering divergent branches, Git might show:
   ```
   hint: You have divergent branches and need to specify how to reconcile them.
   hint: You can do so by running one of the following commands sometime before
   hint: your next pull:
   hint:
   hint:   git config pull.rebase false  # merge (the default strategy)
   hint:   git config pull.rebase true   # rebase
   hint:   git config pull.ff only       # fast-forward only
   ```

5. Choose the merge strategy (if prompted)
   ```bash
   # Use merge (recommended for beginners)
   git config pull.rebase false
   
   # Then try pulling again
   git pull
   ```

   **Understanding the strategies:**
   - **Merge (false)**: Creates a merge commit combining both histories
     - Preserves complete history
     - Shows when branches diverged and merged
     - Easier to understand for beginners
     - This is what we'll use
   
   - **Rebase (true)**: Replays your commits on top of the remote commits
     - Creates a linear history (cleaner looking)
     - Rewrites commit history (can cause problems for shared branches)
     - More advanced technique
     - Avoid on shared branches like main
   
   - **Fast-forward only (only)**: Only updates if no divergence
     - Safest option (prevents automatic merging)
     - Requires manual merge if branches diverged
     - Good for preventing surprises
   
   **For this course, we recommend merge** (pull.rebase false) because it:
   - Preserves all history
   - Is easier to understand
   - Is safer for beginners
   - Shows what actually happened

6. You'll get a merge conflict!
   ```
   Auto-merging hello.py
   CONFLICT (content): Merge conflict in hello.py
   Automatic merge failed; fix conflicts and then commit the result.
   ```

7. Open the file to see the conflict markers
   ```bash
   cat hello.py
   ```

   You'll see something like this:
   ```
   <<<<<<< HEAD
   print("Hello from my local computer!")
   print("This version was edited locally")
   =======
   print("Hello from GitHub!")
   print("This version was edited on GitHub")
   >>>>>>> abc123def456 (commit hash from GitHub)
   ```

   **Understanding the conflict markers:**
   - `<<<<<<< HEAD` - Start of your local changes
   - `=======` - Separator between the two versions
   - `>>>>>>> abc123...` - End of the remote (GitHub) changes
   - Everything between `<<<<<<< HEAD` and `=======` is YOUR local version
   - Everything between `=======` and `>>>>>>>` is the REMOTE version from GitHub

8. Resolve the conflict
   
   You have three options:
   - **Keep your local version** - Delete the remote version and all markers
   - **Keep the remote version** - Delete your local version and all markers
   - **Merge both** - Combine the best of both and delete all markers

   Let's merge both versions. Edit the file to look like this:
   ```bash
   cat > hello.py << 'EOF'
   print("Hello from both GitHub and local computer!")
   print("This version combines both edits")
   print("Local version: edited locally")
   print("GitHub version: edited on GitHub")
   EOF
   
   # View the resolved file
   cat hello.py
   ```

   **Important:** Make sure ALL conflict markers are removed:
   - No `<<<<<<<`
   - No `=======`
   - No `>>>>>>>`

9. Check the status
   ```bash
   git status
   ```

9. Check the status
   ```bash
   git status
   ```

   You'll see:
   ```
   Unmerged paths:
     (use "git add <file>..." to mark resolution)
           both modified:   hello.py
   ```

10. Mark the conflict as resolved
    ```bash
    # Stage the resolved file
    git add hello.py
    
    # Check status again
    git status
    
    # Now it says "All conflicts fixed but you are still merging"
    ```

11. Complete the merge
    ```bash
    # Commit the merge
    git commit -m "Merge local and GitHub changes to hello.py"
    ```

    Git may open a default merge commit message. If it does, you can use it or edit it, then save and close.

12. **Challenge: Push the merged changes**
    ```bash
    # Push the resolved conflict to GitHub
    
    
    # Your command here
    ```

13. View the history
    ```bash
    git log --oneline --graph --all
    
    # You'll see a merge commit combining both branches
    ```

14. Verify on GitHub
    - Go to your repository on GitHub
    - Click on `hello.py`
    - You should see your merged version with content from both sources!
    ```

12. Verify on GitHub
    - Go to your repository on GitHub
    - Click on `hello.py`
    - You should see your merged version with content from both sources!

**Key Lessons:**
- Always pull before starting work to avoid conflicts
- Conflict markers show you both versions: `<<<<<<< HEAD` (yours), `=======` (separator), `>>>>>>>` (remote)
- You must manually edit the file to resolve conflicts
- Remove ALL conflict markers (`<<<<<<<`, `=======`, `>>>>>>>`)
- Stage the resolved file with `git add`
- Complete the merge with `git commit`
- Then push to GitHub

## Part 8: Best Practices SummaryCreate a new file documenting what you've learned:

```bash
cat > git-workflow.md << 'EOF'
# Git Push and Pull Best Practices

## Daily Workflow

1. **Start your day:**
   - `git pull` - Get latest changes
   
2. **Make changes:**
   - Edit files
   - Test your code
   
3. **Commit frequently:**
   - `git status` - See what changed
   - `git diff` - Review changes
   - `git add <files>` - Stage changes
   - `git commit -m "Clear message"` - Commit
   
4. **Push regularly:**
   - `git push` - Upload to GitHub
   - Push at least once per session
   
5. **Before finishing:**
   - `git status` - Ensure nothing is uncommitted
   - `git push` - Final push of the day

## Key Commands

- `git fetch` - Download info about changes (doesn't apply them)
- `git pull` - Download AND apply changes (fetch + merge)
- `git push` - Upload your commits to GitHub
- `git status` - Check current state
- `git diff` - See unstaged changes
- `git diff --staged` - See staged changes
- `git log --oneline` - View commit history

## Remember

- Pull before you start working
- Commit often with clear messages
- Push frequently to back up work
- Always pull before pushing if working with others
- Use `git status` liberally - it's your friend!
EOF

cat git-workflow.md
```

**Challenge: Stage, commit, and push this new file**
```bash
# Add, commit with message "Add Git workflow best practices guide", and push




# Your commands here
```

## Part 9: Practice Makes Perfect

Let's do one final practice round without step-by-step instructions:

**Task 1: Local → GitHub**
- Create a new file called `notes.md`
- Add some notes about what you learned in this lab
- Stage, commit, and push to GitHub
- Verify it appears on GitHub

**Task 2: GitHub → Local**
- Edit `notes.md` on GitHub (add another line)
- Pull the changes to your local repository
- Verify the change is in your local file

**Task 3: Multiple commits**
- Make 3 different changes locally (edit different files)
- Commit each change separately with descriptive messages
- Push all 3 commits to GitHub at once
- View the commit history on GitHub

## Cleanup

**Keep your repository!** You've built up a good practice repository with real Git history.

If you want to start fresh later:
```bash
cd ~/Documents
rm -rf git_practice

# Then clone it again from GitHub
git clone https://github.com/yourusername/git_practice.git
```

## Conclusion

In this lab, you mastered the fundamental Git workflow that you'll use every single day as a developer:

- **Push workflow**: Making local changes, committing them, and pushing to GitHub
- **Pull workflow**: Fetching and pulling changes from GitHub to your local repository
- **git fetch vs git pull**: Understanding the difference and when to use each
- **git diff**: Viewing changes before committing
- **Multiple commits**: Making several commits before pushing
- **Sync issues**: Handling repositories that are out of sync
- **Merge conflicts**: Understanding conflict markers and how to resolve them manually
- **Conflict resolution**: Editing files to remove markers and combine changes
- **Best practices**: When to pull, commit, and push for optimal workflow
- **Self-sufficiency**: Figuring out commands based on what you've learned

The push-pull workflow is the heartbeat of Git collaboration. Whether you're working solo or with a team of 100, you'll use these commands dozens of times per day.

**Key takeaway:** Pull often, commit frequently, push regularly. Your future self (and your teammates) will thank you!

## Next Steps

- Practice this workflow with your own projects
- Try making changes from multiple computers (if available)
- Experiment with `git log` options to view history different ways
- Learn about branches for working on features independently
- Explore merge conflicts and how to resolve them (coming in future labs)
