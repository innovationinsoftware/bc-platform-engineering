# Essential Git Commands

Now that you understand the basic Git workflow of committing, pushing, and pulling, it's time to learn the essential commands that will make you productive with Git. These are the tools you'll use daily to configure Git, view history, undo mistakes, save work in progress, and explore your project's past.

Every developer encounters situations where they need to undo a change, temporarily save work, or investigate what a file looked like last week. This lab teaches you the essential Git commands to handle these real-world scenarios confidently.

### Estimated Time: 45 Minutes

**Prerequisites:** Complete Labs 1.1, 1.2, and 1.3. You should have your `git_practice` repository with some commit history.

## Part 1: Git Configuration - Setting Your Identity

Before going further, let's make sure Git knows who you are. This information appears in every commit you make.

1. Check your current Git configuration
   ```bash
   cd ~/Documents/git_practice
   
   # View your current username
   git config user.name
   
   # View your current email
   git config user.email
   ```

2. Set your username and email (if not already set)
   ```bash
   # Set your name (use your real github username)
   git config --global user.name "Your Full Name"
   
   # Set your email (use the email associated with your GitHub account)
   git config --global user.email "your.email@example.com"
   ```

   The `--global` flag sets this for all repositories on your computer.

3. Verify the changes
   ```bash
   git config user.name
   git config user.email
   ```

4. View all your Git configuration
   ```bash
   git config --list
   
   # You'll see many settings, including user.name and user.email
   ```

5. View where configuration is stored
   ```bash
   # Global config file (affects all repositories)
   cat ~/.gitconfig
   
   # You'll see your name and email here
   ```

**Why this matters:** Your name and email appear in every commit. When collaborating with others or contributing to open source, this is how people know who made each change.

## Part 2: Viewing History in Detail

You've used `git log --oneline` before. Let's explore more powerful ways to view your project's history.

1. View detailed commit history
   ```bash
   # Full detailed log
   git log
   
   # Shows: commit hash, author, date, and full message
   # Press 'q' to exit
   ```

2. View compact history
   ```bash
   # One line per commit
   git log --oneline
   
   # Easier to scan through many commits
   ```

3. View history with a graph
   ```bash
   # Graphical representation
   git log --oneline --graph --all
   
   # Shows branches and merges visually
   ```

4. View commits by a specific author
   ```bash
   # Replace with your name
   git log --author="Your Name"
   ```

6. View commits in the last week
   ```bash
   git log --since="1 week ago"
   
   # Also works: "2 days ago", "1 month ago", "2023-01-01"
   ```

7. View what changed in the last commit
   ```bash
   git show
   
   # Shows the most recent commit without needing the hash
   ```

**Challenge: Find a specific commit**
```bash
# Use git log options to find:
# 1. When you created calculator.py
# 2. What exactly changed in that commit




# Your commands here
```

## Part 3: Undoing Changes - Git Restore

Sometimes you make changes to a file and want to discard them. `git restore` is your friend.

1. Make a change you'll want to undo
   ```bash
   # Modify calculator.py
   echo "# This is a mistake!" >> calculator.py
   
   # View the change
   git diff
   ```

2. Discard the change (restore from last commit)
   ```bash
   # Restore the file to its last committed state
   git restore calculator.py
   
   # Check that the change is gone
   git diff
   # Nothing! It's back to the committed version
   
   cat calculator.py
   # The line we added is gone
   ```

3. Restore a file that's been staged
   ```bash
   # Make a change and stage it
   echo "# Another mistake!" >> calculator.py
   git add calculator.py
   
   # Check status
   git status
   # Shows: "Changes to be committed"
   ```

4. Unstage the file
   ```bash
   # Remove from staging area (but keep the change in the file)
   git restore --staged calculator.py
   
   # Check status
   git status
   # Now shows: "Changes not staged for commit"
   ```

5. Now discard the unstaged change
   ```bash
   # Discard the change from the working directory
   git restore calculator.py
   
   git status
   # Clean! 
   # Inspect calculator.py
   ```

**Key Points:**
- `git restore <file>` - Discard changes in working directory
- `git restore --staged <file>` - Unstage file (keep changes)
- `git restore .` - Restore ALL files (use carefully!)

## Part 4: Undoing Commits - Git Revert

What if you already committed a change and want to undo it? `git revert` creates a new commit that undoes a previous commit.

1. Make a commit we'll want to undo
   ```bash
   # Create a file with wrong information
   echo "Python was invented in 1950" > facts.txt
   
   # Commit it
   git add facts.txt
   git commit -m "Add facts file"
   ```

2. Realize the mistake and create a revert commit
   ```bash
   # Get the commit hash
   git log --oneline
   # Note the hash of the "Add facts file" commit
   
   # Revert it (replace abc123 with actual hash)
   git revert abc123
   ```

   Git will open a text editor with a default message: "Revert 'Add facts file'"
   - You can keep this message or edit it
   - Save and close the editor (in nano: Ctrl+O, Enter, Ctrl+X)

3. View what happened
   ```bash
   # Check the log
   git log --oneline
   
   # You'll see TWO commits:
   # 1. The original "Add facts file"
   # 2. A new "Revert 'Add facts file'"
   
   # Check if the file is gone
   ls
   # facts.txt is gone!
   ```

4. View the revert in detail
   ```bash
   git show
   
   # Shows the revert commit undid the addition of facts.txt
   ```

**Why use revert instead of deleting the commit?**
- Revert is SAFE - it doesn't rewrite history
- The original commit stays in the log
- Perfect for commits already pushed to GitHub
- Shows a clear history of what happened

**Challenge: Push the revert**
```bash
# Push both commits (original and revert) to GitHub



# Your command here
```

## Part 5: Git Stash - Saving Work in Progress

Imagine you're in the middle of coding when you need to switch tasks urgently. You're not ready to commit, but you need a clean working directory. That's where `git stash` comes in.

1. Start making changes
   ```bash
   # Modify multiple files
   echo "# Work in progress" >> calculator.py
   echo "def new_feature():" >> calculator.py
   echo "    pass" >> calculator.py
   
   echo "## Work in Progress" >> README.md
   echo "Currently adding a new feature" >> README.md
   
   # Check status
   git status
   # Multiple files modified
   ```

2. Stash the changes
   ```bash
   # Save all changes to a stash
   git stash
   
   # Or with a descriptive message
   git stash push -m "WIP: new calculator feature"
   ```

3. Verify your working directory is clean
   ```bash
   git status
   # Nothing to commit, working tree clean
   
   cat calculator.py
   # The changes are gone (temporarily)
   ```

4. View your stashes
   ```bash
   git stash list
   
   # Shows: stash@{0}: On main: WIP: new calculator feature
   ```

5. Do some other work
   ```bash
   # Make a quick fix
   echo "# Quick fix applied" >> notes.txt
   git add notes.txt
   git commit -m "Quick fix to notes"
   ```

6. Restore your stashed work
   ```bash
   # Apply the most recent stash
   git stash pop
   
   # Your work in progress is back!
   cat calculator.py
   # Changes are restored
   
   git status
   # Changes show up as modified again
   ```

7. View stash contents without applying
   ```bash
   # First, stash your current work again
   git stash
   
   # View what's in the stash without applying it
   git stash show
   
   # View detailed changes in the stash
   git stash show -p
   ```

8. Apply a stash without removing it
   ```bash
   # Apply stash but keep it in the stash list
   git stash apply
   
   # Check stash list
   git stash list
   # Still there!
   
   # Clear the stash list
   git stash clear
   ```

**Stash Commands Summary:**
- `git stash` or `git stash push -m "message"` - Save changes
- `git stash list` - View all stashes
- `git stash show` - Preview stash contents
- `git stash pop` - Apply and remove stash
- `git stash apply` - Apply but keep stash
- `git stash drop` - Delete a specific stash
- `git stash clear` - Delete all stashes

## Part 6: Understanding Fetch vs Pull

You've used `git pull`, but what about `git fetch`? Let's understand the difference.

1. Make a change on GitHub
   - Go to your repository on GitHub
   - Edit `README.md`
   - Add a line: `## Updated from GitHub`
   - Commit the change

2. Fetch the changes (don't apply them yet)
   ```bash
   # Download info about changes
   git fetch
   
   # Check status
   git status
   # Says: "Your branch is behind 'origin/main' by 1 commit"
   ```

3. View what was fetched
   ```bash
   # View the remote commits
   git log origin/main
   
   # Compare with your local main
   git log main
   
   # See the difference
   git log main..origin/main
   # Shows commits on GitHub that you don't have locally
   ```

4. View the changes without merging
   ```bash
   # See what changed on GitHub
   git diff main origin/main
   
   # Shows the exact changes that will be applied
   ```

5. Now merge the fetched changes
   ```bash
   # Pull = fetch + merge
   git pull
   
   # Or you can merge manually after fetch:
   # git merge origin/main
   ```

**Key Differences:**
- `git fetch` - Downloads changes but doesn't modify your files (safe to run anytime)
- `git pull` - Downloads changes AND merges them into your current branch (fetch + merge)

**Best Practice:** Use `git fetch` to see what's new, then `git pull` when you're ready to merge.

## Part 7: Git Reset - Use with Caution

`git reset` is powerful but dangerous. It moves the branch pointer and can change history. Use it carefully!

1. Create a few test commits
   ```bash
   # Commit 1
   echo "Test 1" > test.txt
   git add test.txt
   git commit -m "Test commit 1"
   
   # Commit 2
   echo "Test 2" >> test.txt
   git add test.txt
   git commit -m "Test commit 2"
   
   # Commit 3
   echo "Test 3" >> test.txt
   git add test.txt
   git commit -m "Test commit 3"
   
   # View history
   git log --oneline
   ```

2. Reset to undo the last commit (keep changes)
   ```bash
   # Soft reset - moves HEAD but keeps changes staged
   git reset --soft HEAD~1
   
   # Check status
   git status
   # Changes are still staged!
   
   cat test.txt
   # File still has all content
   
   # View history
   git log --oneline
   # Last commit is gone, but changes are ready to commit again
   ```

3. Recommit to restore (since we were just testing)
   ```bash
   git commit -m "Test commit 3"
   ```

4. Reset to undo last commit (unstage changes)
   ```bash
   # Mixed reset (default) - moves HEAD and unstages changes
   git reset HEAD~1
   
   # Check status
   git status
   # Changes are unstaged but still in the file
   
   # View history
   git log --oneline
   # Commit is gone
   ```

5. Recommit again
   ```bash
   git add test.txt
   git commit -m "Test commit 3"
   ```

6. Reset to undo and delete changes (dangerous!)
   ```bash
   # Hard reset - moves HEAD and deletes changes
   # WARNING: This permanently deletes uncommitted work!
   
   git reset --hard HEAD~1
   
   cat test.txt
   # The last change is GONE permanently
   
   git log --oneline
   # Commit is gone
   ```

**Reset Types:**
- `--soft` - Move HEAD, keep changes staged
- `--mixed` (default) - Move HEAD, unstage changes, keep in working directory
- `--hard` - Move HEAD, delete all changes (DANGEROUS!)

**When to use reset:**
- You committed too early and want to add more changes
- You want to combine several commits into one
- You made commits locally that you haven't pushed yet

**WARNING:** Never use `git reset` on commits you've already pushed to GitHub! It rewrites history and will cause problems for others. Use `git revert` instead for pushed commits.

## Part 8: Time Travel - Viewing Old Commits

Sometimes you need to see what your project looked like in the past. You can checkout old commits to explore.

1. View your commit history
   ```bash
   git log --oneline
   
   # Note a commit hash from several commits ago
   ```

2. Checkout an old commit
   ```bash
   # Replace abc123 with an actual old commit hash
   git checkout abc123
   ```

   You'll see a message about "detached HEAD state":
   ```
   You are in 'detached HEAD' state. You can look around, make experimental
   changes and commit them, and you can discard any commits you make in this
   state without impacting any branches by switching back to a branch.
   ```

3. Explore the old state
   ```bash
   # List files as they were
   ls
   
   # View a file as it was
   cat calculator.py
   
   # View commits from that point
   git log --oneline
   ```

4. Return to the present
   ```bash
   # Go back to your main branch
   git checkout main
   
   # Or use the newer command:
   git switch main
   ```

5. Verify you're back
   ```bash
   git status
   # On branch main
   
   ls
   # All current files are back
   ```

**Detached HEAD explained:**
- HEAD normally points to a branch (like `main`)
- When you checkout a commit hash, HEAD points directly to that commit
- You're in "detached" state - not on any branch
- You can look around safely
- Always return to a branch before continuing work

**Use cases:**
- "What did this file look like last week?"
- "When did this bug appear?"
- "Show me the code from version 1.0"

## Part 9: Practical Scenarios

Let's practice everything together with real-world scenarios.

**Scenario 1: You committed sensitive data by mistake**

```bash
# Oh no! You committed a password
echo "PASSWORD=secretpass123" > config.txt
git add config.txt
git commit -m "Add config"

# Fix it quickly (before pushing!)
git reset --soft HEAD~1
rm config.txt
echo "config.txt" >> .gitignore
git add .gitignore
git commit -m "Add gitignore for config files"
```

**Scenario 2: You need to switch tasks urgently**

```bash
# You're in the middle of work
echo "# Incomplete feature" >> new-feature.py

# Boss needs a quick fix RIGHT NOW
git stash push -m "Half-done feature work"

# Make the urgent fix
echo "# Critical fix" >> calculator.py
git add calculator.py
git commit -m "Critical bug fix"

# Push the fix
# (Challenge: use the push command)

# Resume your feature work
git stash pop
```

**Scenario 3: You want to undo a pushed commit**

```bash
# You pushed a commit that breaks production
# Don't use reset! Use revert:

git log --oneline
# Find the bad commit hash

git revert abc123
# Creates a new commit that undoes it

# Push the revert
# (Challenge: use the push command)
```

**Scenario 4: Checking if a bug existed in an old version**

```bash
# Find when the bug was introduced
git log --oneline

# Check out an old version
git checkout abc123

# Test the code (was the bug there?)
cat calculator.py

# Return to present
git switch main
```

## Part 10: Command Cheat Sheet

Create a reference file for yourself:

```bash
cat > git-commands-cheatsheet.md << 'EOF'
# Git Essential Commands Cheat Sheet

## Configuration
- `git config --global user.name "Name"` - Set username
- `git config --global user.email "email"` - Set email
- `git config --list` - View all configuration

## Viewing History
- `git log` - Full commit history
- `git log --oneline` - Compact history
- `git log --oneline --graph --all` - Visual history
- `git log --author="Name"` - Filter by author
- `git log --since="1 week ago"` - Filter by date
- `git show` - Show last commit
- `git show abc123` - Show specific commit

## Undoing Changes
- `git restore <file>` - Discard working directory changes
- `git restore --staged <file>` - Unstage file
- `git revert <commit>` - Create new commit undoing a commit (safe)
- `git reset --soft HEAD~1` - Undo commit, keep changes staged
- `git reset HEAD~1` - Undo commit, unstage changes
- `git reset --hard HEAD~1` - Undo commit, delete changes (DANGER!)

## Stashing
- `git stash` - Save work in progress
- `git stash push -m "message"` - Stash with description
- `git stash list` - View all stashes
- `git stash show` - Preview latest stash
- `git stash pop` - Apply and remove stash
- `git stash apply` - Apply but keep stash
- `git stash drop` - Delete a stash
- `git stash clear` - Delete all stashes

## Fetching and Pulling
- `git fetch` - Download changes (don't merge)
- `git pull` - Download and merge changes (fetch + merge)
- `git log main..origin/main` - See remote commits

## Time Travel
- `git checkout <commit>` - View old commit (detached HEAD)
- `git switch main` - Return to branch

## Remember
- Use `revert` for pushed commits (safe)
- Use `reset` only for local commits (rewrites history)
- Always `fetch` or `pull` before starting work
- Stash when you need to switch contexts quickly
- Never reset commits that are on GitHub!
EOF

cat git-commands-cheatsheet.md
```

**Challenge: Commit and push the cheat sheet**
```bash
# Add, commit, and push git-commands-cheatsheet.md to GitHub




# Your commands here
```

## Cleanup

Keep your repository! All the commands you practiced are essential daily tools.

If you want to clean up the test files:
```bash
# Remove test.txt if it exists
git rm test.txt
git commit -m "Remove test file"
git push
```

## Conclusion

In this lab, you learned the essential Git commands that every developer uses daily:

- **Configuration**: Setting your identity with `user.name` and `user.email`
- **Viewing history**: Using `git log` with various options to explore your project's past
- **git restore**: Discarding unwanted changes and unstaging files
- **git revert**: Safely undoing commits by creating new commits
- **git reset**: Moving branch pointers (use cautiously and never on pushed commits!)
- **git stash**: Temporarily saving work in progress
- **fetch vs pull**: Understanding the difference and when to use each
- **Time travel**: Checking out old commits to view historical states
- **Real-world scenarios**: Applying these commands to solve common problems

These commands give you confidence to experiment, knowing you can always undo mistakes. Git's power comes from making version control safe and reversible.

**Key Principle:** Git has your back. Almost nothing is truly lost in Git. Even if you mess up, there's usually a way to recover.

## Next Steps

- Practice these commands regularly until they become second nature
- Use `git reflog` to see a log of all HEAD movements (advanced recovery tool)
- Learn about branches (coming in the next lab!)
- Explore `git bisect` for finding bugs in history
- Study `git cherry-pick` for applying specific commits
